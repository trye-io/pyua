# Кортежі `tuple`

<!-- Може краще назвати контейнери чи коллекції -->
<!-- Мабудь ні, тому що тоді доведеться додавати сюди str -->

| Назва                 | Посилання |
|-----------------------|-----------|
| Лекція в YouTube      | https://  |
| Подкаст-лекція        | https://  |
| Код в Google Colab    | https://  |
| Вправи в Google Forms | https://  |

Слухати:

Приблизний час на опанування теми: 15 хвилин

Для чого ми це вивчаємо:

Результати навчання:

- Створювати змінні
- Використовувати та змінювати занчення змінних
- Викликати функцію та зазначати аргументи
- Використовувати математичні оператори

Шпаргалка: summarized.pdf

---

У цій главі, ми будемо вивчати чи не найважливіший контейнер. 

---

Гарна новина у тому, що котежі `tuple` дуже і дуже схожі в роботі на списки `list`. Та що там, вони практично ідентичні і поводяться майже як списки `list`. Тому все що ми вивчили для `list` можна використати і для кортежей `tuple`.

Проте є одна дуже важлива критична відмінність -- тоді як списки `list` можна змінити, кортежі **`tuple` є незмінними**. Після того як ми створили `tuple`, ми вже **не можемо** ані додати, ані видалити, ані змінити його елементи.

Щоб створити новий кортеж, ми можемо використати звичайні дужки замість квадратних, які ми використовємо для `list`. Тобто елементи повинні бути загорнуті в ось такі дужки: `(` та `)`.

Давайте створимо новий `tuple` із назвою `baltic_states`, який буде містити назви Балтійських країн: 

```{python}
baltic_states = ("Estonia", "Latvia", "Lithuania")
baltic_states
```

Це не єдиний спосіб створити `tuple` -- нам не обов'язково зазначати дужки, ми можемо просто перелічити прості елементи через кому `,`: 

```{python}
baltic_states = "Estonia", "Latvia", "Lithuania"
baltic_states
```

Як ми й сказали, так само як і у `list`, доступ до елементів виконується через індекси: 

```{python}
baltic_states[2]
```

Слайсіг теж працює:

```{python}
baltic_states[0:2]
```

Але якщо ви спробуєте замінити який елемент, то Python викене помилку: 

```{python, error = TRUE}
baltic_states[2] = "Vilnius"
```

Як наслідок, багато методів які змінювали `list`, **не** будуть працювати з `tuple`: 

* `.append()`: додати елемент
* `.insert()`: додати елемент
* `.remove()`: видалити елемент(и)
* `.pop()`: видалити елемент
* `.reverse()`: змінити порядок елементів на зворотній
* `.sort()`: відсортувати елементи

До речі, у `tuple`, як і у `list` є дуже корисна властивість -- їх можна **розпакувати**. Це означає присвоїти значення елементів послідовності до окремих змінних. Це простіше показати, ніж розказувати про це:

```{python}
a, b, c = baltic_states
print(a)
print(b)
print(c)
```

Тепер ми можемо працювати зі змінними `a`, `b` та `c`, як з окремими змінними. Нам це знадобиться у Главі \@ref(functions).

Природньо спитати -- а навіщо нам взагалі тоді `tuple`, якщо вони більше обмежані ніж `list`? Є три причини чому ми можемо віддати перевагу `tuple`: 

- `tuple` використовють меньше пам'яті ніж `list`. Операції над ними також проходять швидше за операціх над `list`. В нашому випадку це дуже важко помітити, тому що об'єми даних і програми наші дуже малі. Але якщо ми це все масштабуємо, то в певний момент ця різниця може бути критичною. 

- `tuple` незмінні, і це дозволяє нам створювати об'єкти, які будуть захищені від випадкових змін.

- `tuple` незмінні, тому їх можна використовувати як ключі для словників `dict`.

Так, стоп, а що таке словники `dict`? Саме про це ми й поговоримо в наступній главі. 

--- 

---