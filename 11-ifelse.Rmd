# (PART\*) Потоки керування {-}

# Умовний перехід `if/elif/else` {#ifelse}

| Назва                 | Посилання |
|-----------------------|-----------|
| Лекція в YouTube      | https://  |
| Подкаст-лекція        | https://  |
| Код в Google Colab    | https://  |
| Вправи в Google Forms | https://  |

Слухати:

Приблизний час на опанування теми: 15 хвилин

Для чого ми це вивчаємо:

Результати навчання:

- Розуміння що таке програма, додаток та програмне забезпечення
- Розуміння що таке алгоритм, кодування та програмування 

Шпаргалка: summarized.pdf

---

У цій главі ми познайомимось з...

---

## Блок-схема

До сих пір, ми розглядали інструцкії які йдуть одна за одною, або іншими словами -- послідовність інструкцій. Давайте подивимось на набір інструцкій унизу:

```{python}
x = 12
y = 43
distance = y - x
distance = str(distance)
print("Відстань між x та y: " + distance)
```

Спочатку ми присвоїли `12` до `x`; потім ми присвоїли `43` до `y`; порахували різницю між `x` та `y` і присвоїли результат до змінної `distnace`; далі ми перетворили `distance` на тип `str`; і нарешті роздрукували наш результат з коментарями. Іншими словами, це маленький уривок коду рахує відстань між `x` та `y` та друкує його на екран. Давайте спробуємо зобразити це у вигляді блок-схеми: 

<!-- XXX: flowchart of instructions -->

Нам вдалося досить легко це зобразити, а ми ще навіть не знаємо що таке блок-схема. Блок-схема -- це діаграма або візуалізація якогось алгоритму. В цій блок-схемі, інструкція позначається прямокутником, а початок та кінець алгорітму за допомогою прямокутника із закругленими кутами. Як ви вже зрозуміли, самі інструкції ми будемо писати всередині фігур. Прямокутники з'єднані стрілками, які вказують на послідновність виконання. Зазвичай, блок-схема читається зверху вниз. 

## Конструкція `if/else`

Ось проблема: якщо наш `x` дорівнює `52`, то замість `y - x`, нам треба порахувати `x - y`. Тому що `x` в цьому випадку буде більший за `y`, а відстань -- це невід'ємне число. Тому нам треба трохи переписати программу: 

```{python}
x = 52
y = 43
distance = x - y # Зверніть увагу, що замість y - x ми використали x - y
distance = str(distance)
print("Відстань між x та y: " + distance)
```

Але ж ми не будемо щоразу змінювати программу відповідно до того чи більший `x` за `y`. Тим більше, якщо `x` задається користувачем програми. Ми можемо звичайно загорнути `y - x` у фунцкію `abs()`, яка знаходить модуль числа. Замість цього, ми спробуємо реалізувати цей алгорітм власноруч.

Для цього ми спершу познайомимось з новим елементом блок-схеми -- умовою, яка позначається ромбом. В середині цього ромба ми запишемо умову, яка в нашому випадку буде `x < y`. Далі, з цього ромба виходять дві стрілочки, які позначенні `Так` та `Ні` та з'єднують його з наступними інструкціями. Залежно від істинності чи хибності цієї умови, програма почне виконувати одну з наступних команд. Так би мовити піде по тому чи іншому "сценарію". Ці "сценарії" можуть бути повністю незалежними до самого кінця програми або в певний момент об'єднуватись в один потік (як у нашому випадку). 

<!-- XXX: flowchart with if/else of instructions -->

<!-- XXX: flowchart with if/else: independent vs joined scenarios -->

Тепер давайте подивимос, як це робиться у Python. Це буде спеціальна конструкція з ключовимв словами `if` та `else`^[Це не унікальна для Python конструкція, і використовується в багатьох мовах програмування.]. Слово `if` перекладається як `якщо`, а `else`, як `інашке`, що дуже природьно читається у коді. Умова повинна бути обгорнута у дужки, та не забувайте поставити двокрапки. Кількість інструкцій в обох потоках не обмежанна. Усі інструкції які повинні виконатись якщо умова є істинною розташовуються з нового рядку після `if`. І так само, усі інтрукції які повинні виконатись якщо умова є недійсою розташовуються з нового рядку після `else`. До речі, інструкції які виконуються за певних умов об'єднуються в так звані блоки коду, і ці блоки коду повинні починатись не з початку рядка, а післня чотирьох пробілів, які називається відступ.

<!-- XXX: diagram of if/else of construction -->

Умова може бути будь яким виразом чи змінною, які повертають бульове значення -- `True` або `False`. Якщо значення `True`, то виконається блок коду під `if`, інакше -- блок коду що під `else`. Коли ми бачимо щось накшталт `if (x > 5):`, ми читаємо це як "if x is greater than five is true, then...", що перекладається на українську як: "якщо x більший за п'ять є істинною, тоді...".

Якщо в певний момент ці потоки об'єднуться, то спільні інструкції можуть бути записані після блоку коду для `else`. Це буде виглядати приблизно ось так: 

```{python, eval = FALSE}
if умова: 
    інструкції якщо умова істинна
else: 
    інструкції якщо умова хибна
спільні інструкції
```

Давайте тепер перепишемо наш код використовуючи цю конструкцію який буде враховувати умову `x > y`:

```{python}
x = 52
y = 43
if x > y:
    distance = x - y 
else: 
    distance = y - x
distance = str(distance)
print("Відстань між x та y: " + distance)
```

Так як наш `x` більший за `y`, то виконається команда `distance = x - y`. Якщо ми змінемо `x` назад на `12`, то код все одно роздрукую правильну відстань: 

```{python}
x = 12
y = 43
if x > y:
    distance = x - y 
else: 
    distance = y - x
distance = str(distance)
print("Відстань між x та y: " + distance)
```

У цьому випадку, так як `x` не більший за `y`, то ми потрапили до випадку `else` і Python виконав код `distance = y - x`.

Якщо інструкції в умвному переході невелчкі, ми можемо скористатись скороченням. Це так не впливає на фунцкіональність умовного переходу, а тільки спрощує код. Це не найважливіше, що нам зараз треба навчитись, тому ми залишимо це у Додатку \@ref(sugar).

## Використовуємо поодинокий `if`

Не завжди нам потрібен потік `else`. Бувають випадки коли нам достатньо використати тільки частину `if`. На блок-схемі це буде виглядати ось так: 

<!-- XXX: diagram of if of construction -->

Зверніть увагу, що стрілка після інструкції `Так` входить в інструкцію після `Ні`. Тобто блок коду піля `if` буде виконаний якщо умова істина. В іншому випадку, Python просто пропустить її. Ця конструкція у Python виглядатиме ось так: 

```{python, eval = FALSE}
if умова: 
    інструкції якщо умова істинна
подальші інструкції
```

Наприклад, в Україні ми вимірюємо швидкість у кілометрах на годину. Автівки в США ж використовють милі на годину. Якщо у нас саме така автівка, нам треба перевести милі на годину у кілометри на годину: 

```{python, eval = FALSE}
country = "USA"
speed = 25

if (country == "USA"): # ми вивчимо що саме означає == за декілька хвилин
    speed = speed * 1.6

print("Ваша швидкість зараз " + str(speed) + " км/год")
```

Якщо ж країна у нас дорівнє `"Ukraine"`, тоді Python пропустить конструкцію `if` і просто роздрукує швидкість: 

```{python}
country = "Ukraine"
speed = 25

if (country == "USA"):
    speed = speed * 1.6 # ця комадна не буде виконана, так як country не є "USA"

print("Ваша швидкість зараз " + str(speed) + " км/год")
```

## Більше випадків за допомогою `elif`

Давайте повернемось до порівняння двох чисел. Нам треба роздрукувати на екран фразу, яка залежіть від того який у нас випадок: 

- `x` більший `y`
- `x` меньший `y`
- `x` дорівнює `y`

Ми звичайно можемо його реалізувати за допомогою трьох `if`, але є ще один спосіб -- за допомогою `elif`. Ключове слово `elif` -- скорочення від "else if", що перекладаєтсья як "інакше якщо" і використовується у зв'зці з `if`. По суті своїй, конструкції з `elif` -- це ієрархія або кілька вкладених умов. Давайте подивимось спершу на код, а потім на блок-схему:

```{python}
x = 1
y = 2

if (x > y):
    print("x більший y")
elif (x < y): 
    print("x меньший y")
else:
    print("x дорівнює y")

```

<!-- XXX: flow chart of elif of construction -->

На цій блок-схемі, сценарій **Ні** умови `x > y` переходить в наступне розгалудження `x < y`. Таких `elif` випадків може бути скільки завгодно.

## Розбираємось з умовами та операторами

В умвоних переходах неможливо переоцінити важлиість операторів. Ми розглянемо два типи операторів -- оператори порівняння та логічні оператори. Обидва типи, як і математичні оператори які ми розглянули у Главі \@ref(vars), натхненні саме операторами з математики.

### Оператори порівнювання

Оператори порівнювання порівнюють лівий та правий операнд та повертають бульове значення `True` або `False`, залежно від істинності твердження. Наприклад: 

```{python}
3 < 5
```

А хибне твердження поверне `False`:

```{python}
3 > 5
```

Дуже важливим є оператор `==`. Він перевіряє чи дорівнює лівий операнд правому. Як і в випадку математичних операторів, операнди можуть бути будь-чим: змінними, значеннями, виразами тощо. Будьте обережні, тому що використання `=` замість `==` дуже поширенна помилка. Ще раз: 

- `=`: це оператор присвоєнная, наприклад `x = 4`
- `==`: це оператор порівнювання, наприклад `x == y`

Давайте спробуємо його використати: 

```{python}
x = 4
y = 4
if (x == y): 
    print("x дорівнює y")

```

А тепер навмисно зробити помилку: 

```{python, error = TRUE}
x = 4
y = 4
if (x = y): 
    print("x дорівнює y")

```

Нижче ви знайдете таблицю усіх операторів порівняння: 

| Оператор   | Зміст                        |
|------------|------------------------------|
| `x > y`    | `x` більший `y`              |
| `x >= y`   | `x` більший або дорівнює `y` |
| `x < y`    | `x` меньший `y`              |
| `x <= y`   | `x` меньший або дорівнює `y` |
| `x == y`   | `x` дорівнює `y`             |
| `x != y`   | `x` не дорівнює `y`          |

Ці оператори працюють не тільки з числовими об'єктами, а ще й з `str`. У випадку `str` операнди будуть порівнюватись за допомогою лексикографічних порядку. Наприклад, `"a"` меньша ніж `"b"`, тому що літера `"a"` йде перед літерою `"b"`:

```{python}
"a" < "b"
```

### Логічні опрератори 

Нам ще знадобляться логічні опрератори. Вони дозволяють комбінувати умови. Таких операторів у нас три: `not`, `and` та `or`, і вони відповідають українським словам "не", "та" та "або". 

Оператор `not` використовується коли нам треба змінити результат умови на протилежну. Тобто якщо у нас умова повертає `True`, то в поєднанні з `not` вона поверне `False`, і навпаки, коли умова поверне `False`, поєднання з `not` поверне `True`. Цей оператор називається логічним запереченням.

Наприклад: 

```{python}
x = 2
if (not x > 3):
    print("x меньший або дорівнює 3")

```

Давайте складемо таблицю результатів цього оператора: 

|   `x`   | `not x` | 
|---------|---------|
| `True`  | `False` |
| `False` | `True`  |

Оператор `and` повертає `True` якщо обидва операнди (ліворуч і праворуч) є `True`. Інакше, він поверне `False`. Наприклад, нам треба впевнитись що дощь не йде (сонячна погода) і тротуар вже сухий, і тільки тоді ми можемо вдягти наше улюбленне взуття:

```{python}
sidewalk = "dry"
weather = "sunny"
if (sidewalk == "dry" and weather == "sunny"):
    print("Вдягай улюбленне взуття!")

```

У цьому прикладі, якщо одна з умов не є `True`, тоді уся умова є `False`, і Python не виконає інструкції що під `if`:

```{python}
sidewalk = "dry"
weather = "rain"
if (sidewalk == "dry" and weather == "sunny"):
    print("Вдягай улюбленне взуття!")

```

А ось таблиця результатів цього оператора: 

|   `x`   |   `y`   | `x and y` | 
|---------|---------|-----------|
| `True`  | `True`  | `True`    |
| `True`  | `False` | `False`   |
| `False` | `True`  | `False`   |
| `False` | `False` | `False`   |

Оператор `or` повертає `True`, якщо принаймні один із операторів є `True`, і `False` інакше. Наприклад, нам треба переконатися що або погода соняшна (`weather == "sunny"`) або зараз день (`time == "day"`), і тільки тоді ми підемо на прогулянку: 

```{python}
time = "day"
weather = "rain"
if (time == "day" or weather == "sunny"):
    print("Йдемо на прогулянку!")

```

Якщо ж зараз ніч та ще і йде дощь, то ніякого сенсу йти на вулицю немає:

```{python}
time = "night"
weather = "rain"
if (time == "day" or weather == "sunny"):
    print("Йдемо на прогулянку!")

```

І традиційно ми покажемо таблицю результатів цього оператора: 

|   `x`   |   `y`   | `x or y` | 
|---------|---------|----------|
| `True`  | `True`  | `True`   |
| `True`  | `False` | `True`   |
| `False` | `True`  | `True`   |
| `False` | `False` | `False`  |

---